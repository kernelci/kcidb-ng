# generated by datamodel-codegen:
#   filename:  kcidb_schema.json
#   timestamp: 2025-03-26T12:24:22+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Literal

from pydantic import AnyUrl, BaseModel, EmailStr, Extra, Field, field_validator, RootModel
import re


class Version(BaseModel):
    class Config:
        extra = Extra.forbid

    major: Literal[5] = Field(
        description='Major number of the schema version.\n\nIncreases represent backward-incompatible changes. E.g. deleting or renaming a property, changing a property type, restricting values, making a property required, or adding a new required property.',
    )
    minor: Optional[int] = Field(
        None,
        description='Minor number of the schema version.\n\nIncreases represent backward-compatible changes. E.g. relaxing value restrictions, making a property optional, or adding a new optional property.',
    )


class Resource(BaseModel):
    class Config:
        extra = Extra.forbid

    name: str = Field(
        ...,
        description='Resource name. Must be usable as a local file name for the downloaded resource. Cannot be empty. Should not include directories.',
    )
    url: AnyUrl = Field(
        ...,
        description='Resource URL. Must point to the resource file directly, so it could be downloaded automatically.',
    )
    
    @field_validator('name')
    def validate_name(cls, v):
        if not v:
            raise ValueError('Resource name cannot be empty')
        if not re.match(r'^[^/\0]+$', v):
            raise ValueError('Resource name cannot include directories')
        return v


class Status(Enum):
    FAIL = 'FAIL'
    ERROR = 'ERROR'
    MISS = 'MISS'
    PASS = 'PASS'
    DONE = 'DONE'
    SKIP = 'SKIP'


class Checkout(BaseModel):
    class Config:
        extra = Extra.forbid
        #orm_mode = True

    field_timestamp: Optional[datetime] = Field(
        None,
        alias='_timestamp',
        description='The last time the checkout was updated in the database.',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    id: str = Field(
        ...,
        description="Source code checkout ID\n\nMust start with a non-empty string identifying the CI system which submitted the checkout, followed by a colon ':' character. The rest of the string is generated by the origin CI system, and must identify the checkout uniquely among all checkouts, coming from that CI system.\n",
    )
    @field_validator('id')
    def validate_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('Invalid checkout ID')
        return v
    origin: str = Field(
        ..., description='The name of the CI system which submitted the checkout'
    )
    @field_validator('origin')
    def validate_origin(cls, v):
        if not re.match(r'^[a-z0-9_]+$', v):
            raise ValueError('Origin must be alphanumeric')
        return v
    tree_name: Optional[str] = Field(
        None,
        description='The widely-recognized name of the sub-tree (fork) of the main code tree where the checked out base source code came from.',
        examples=['net-next', 'rdma', 'mainline'],
    )
    @field_validator('tree_name')
    def validate_tree_name(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Tree name cannot include null characters')
        return v
    git_repository_url: Optional[AnyUrl] = Field(
        None,
        description='The URL of the Git repository which contains the checked out base source code. The shortest possible https:// URL.',
        examples=['https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git'],
    )
    git_commit_hash: Optional[str] = Field(
        None, description='The full commit hash of the checked out base source code'
    )
    @field_validator('git_commit_hash')
    def validate_git_commit_hash(cls, v):
        if v and not re.match(r'^[0-9a-f]{40}$', v):
            raise ValueError('Invalid git commit hash')
        return v
    git_commit_name: Optional[str] = Field(
        None,
        description='A human-readable name of the commit containing the checked out base source code, as would be output by "git describe", at the checkout time.',
    )
    @field_validator('git_commit_name')
    def validate_git_commit_name(cls, v):
        if v and not re.match(r'^[^\0]*$', v):
            raise ValueError('Git commit name cannot include null characters')
        return v
    git_commit_tags: Optional[List[str]] = Field(
        None,
        description='The list of (annotated) tags, found in the checked-out repository, pointing directly at the commit being checked out. I.e. as output by "git tag --points-at <commit>".',
    )
    git_commit_message: Optional[str] = Field(
        None,
        description='The complete message of the commit being checked-out, both the subject and the body. I.e. as output by "git show -s --format=%B".',
    )
    @field_validator('git_commit_message')
    def validate_git_commit_message(cls, v):
        if v and not re.match(r'^[^\0]*$', v):
            raise ValueError('Git commit message cannot include null characters')
        return v
    git_repository_branch: Optional[str] = Field(
        None,
        description='The Git repository branch from which the commit with the base source code was checked out.',
    )
    git_repository_branch_tip: Optional[bool] = Field(
        None,
        description='True if at the moment of checkout (specified in "start_time") the checked out commit was at the tip of the specified branch in the specified repository. False if it was further back in history.\n\nThis information is used to reconstruct the approximate history of the branch changes for display and analyzis, in lieu of actual commit graph walking.',
    )
    patchset_files: Optional[List[Resource]] = Field(
        None,
        description='List of patch files representing the patchset applied to the checked out base source code, in order of application. Each linked file must be in a format accepted by "git apply".',
    )
    patchset_hash: Optional[str] = Field(
        None,
        description='The patchset hash.\n\nA sha256 hash over newline-terminated sha256 hashes of each patch from the patchset, in order. E.g. generated with this shell command: "sha256sum *.patch | cut -c-64 | sha256sum | cut -c-64".\n\nAn empty string, if no patches were applied to the checked out base source code.\n',
        examples=[
            '',
            '903638c087335b10293663c682b9aa0076f9f7be478a8e7828bc22e12d301b42',
        ],
    )
    @field_validator('patchset_hash')
    def validate_patchset_hash(cls, v):
        if not re.match(r'^$|^[0-9a-f]{64}$', v):
            raise ValueError('Invalid patchset hash')
        return v
    message_id: Optional[EmailStr] = Field(
        None,
        description='The value of the Message-ID header of the e-mail message introducing the checked-out source code, if any. E.g. a message with the applied patchset, or a release announcement sent to a maillist.',
    )
    comment: Optional[str] = Field(
        None,
        description='A human-readable comment regarding the checkout. E.g. the checked out release version, or the subject of the message with the applied patchset.',
    )
    @field_validator('comment')
    def validate_comment(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Comment cannot include null characters')
        return v
    start_time: Optional[datetime] = Field(
        None,
        description='The time the checkout was started.',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    origin_builds_finish_time: Optional[datetime] = Field(
        None,
        description='The time the origin of the checkout finished all the builds it planned for it.',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    origin_tests_finish_time: Optional[datetime] = Field(
        None,
        description='The time the origin of the checkout finished all the tests it planned for it.',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    log_url: Optional[AnyUrl] = Field(
        None,
        description="The URL of a plain-text log file of the checkout attempt. E.g. 'git am' output.",
    )
    log_excerpt: Optional[str] = Field(
        None,
        description='A part of the log file of the checkout attempt most relevant to its outcome.',
        examples=[
            'error: patch failed: arch/arm64/boot/dts/qcom/sc7180.dtsi:510\nerror: arch/arm64/boot/dts/qcom/sc7180.dtsi: patch does not apply\n'
        ],
    )
    @field_validator('log_excerpt')
    def validate_log_excerpt(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Log excerpt cannot include null characters')
        return v
    valid: Optional[bool] = Field(
        None,
        description='True if the checkout succeeded, i.e. if the source code parts could be combined. False if not, e.g. if the patches failed to apply.',
    )
    misc: Optional[Dict[str, Any]] = Field(
        None, description='Miscellaneous extra data about the checkout'
    )


class Build(BaseModel):
    class Config:
        extra = Extra.forbid

    field_timestamp: Optional[datetime] = Field(
        None,
        alias='_timestamp',
        description='The last time the build was updated in the database.',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    checkout_id: str = Field(
        ...,
        description='ID of the built source code checkout. The checkout must be valid for the build to be considered valid.',
    )
    @field_validator('checkout_id')
    def validate_checkout_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('Invalid checkout ID')
        return v

    id: str = Field(
        ...,
        description="Build ID\n\nMust start with a non-empty string identifying the CI system which submitted the build, followed by a colon ':' character. The rest of the string is generated by the origin CI system, and must identify the build uniquely among all builds, coming from that CI system.\n",
    )
    @field_validator('id')
    def validate_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('Invalid build ID')
        return v
    origin: str = Field(
        ..., description='The name of the CI system which submitted the build'
    )
    @field_validator('origin')
    def validate_origin(cls, v):
        if not re.match(r'^[a-z0-9_]+$', v):
            raise ValueError('Invalid origin')
        return v
    comment: Optional[str] = Field(
        None, description='A human-readable comment regarding the build'
    )
    @field_validator('comment')
    def validate_comment(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Comment cannot include null characters')
        return v
    start_time: Optional[datetime] = Field(
        None,
        description='The time the build was started',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    duration: Optional[float] = Field(
        None, description='The number of seconds it took to complete the build'
    )
    architecture: Optional[str] = Field(
        None, description='Target architecture of the build'
    )
    @field_validator('architecture')
    def validate_architecture(cls, v):
        if v and not re.match(r'^[a-z0-9_]*$', v):
            raise ValueError('Invalid architecture')
        if not v:
            # TODO: Make this warning somewhere stored
            print(f"FIXME Build has no architecture!!!")
        return v
    
    command: Optional[str] = Field(
        None,
        description='Full shell command line used to make the build, including environment variables',
    )
    @field_validator('command')
    def validate_command(cls, v):
        if v and not re.match(r'^[^\0]*$', v):
            raise ValueError('Command cannot include null characters')
        return v
    
    compiler: Optional[str] = Field(
        None, description='Name and version of the compiler used to make the build'
    )
    @field_validator('compiler')
    def validate_compiler(cls, v):
        if v and not re.match(r'^[^\0]*$', v):
            raise ValueError('Compiler cannot include null characters')
        return v
    input_files: Optional[List[Resource]] = Field(
        None, description='A list of build input files. E.g. configuration.'
    )
    output_files: Optional[List[Resource]] = Field(
        None, description='A list of build output files: images, packages, etc.'
    )
    config_name: Optional[str] = Field(
        None, description='A name describing the build configuration options.'
    )
    @field_validator('config_name')
    def validate_config_name(cls, v):
        if v and not re.match(r'^[^\0]*$', v):
            raise ValueError('Config name cannot include null characters')
        return v
    config_url: Optional[AnyUrl] = Field(
        None, description='The URL of the build configuration file.'
    )
    log_url: Optional[AnyUrl] = Field(
        None, description='The URL of the plain-text build log file.'
    )
    log_excerpt: Optional[str] = Field(
        None,
        description='A part of the log file of the build most relevant to its outcome.',
        examples=[
            'In file included from ./arch/arm64/include/asm/processor.h:35:\n./arch/arm64/include/asm/pointer_auth.h:62:3: error: invalid input constraint \'rZ\' in asm\n                __ptrauth_key_install(APIA, keys->apia);\n                ^\n./arch/arm64/include/asm/pointer_auth.h:55:2: note: expanded from macro \'__ptrauth_key_install\'\n        write_sysreg_s(__pki_v.lo, SYS_ ## k ## KEYLO_EL1);     \\\n        ^\n./arch/arm64/include/asm/sysreg.h:829:37: note: expanded from macro \'write_sysreg_s\'\n        asm volatile(__msr_s(r, "%x0") : : "rZ" (__val));               \\\n                                           ^\n'
        ],
    )
    @field_validator('log_excerpt')
    def validate_log_excerpt(cls, v):
        if v and not re.match(r'^[^\0]*$', v):
            raise ValueError('Log excerpt cannot include null characters')
        return v
    status: Optional[Status] = Field(None, description='Build status')
    misc: Optional[Dict[str, Any]] = Field(
        None, description='Miscellaneous extra data about the build'
    )


class Environment(BaseModel):
    class Config:
        extra = Extra.forbid

    compatible: Optional[List[str]] = Field(
        None,
        description="The values from the root-level 'compatible' property of the system's device tree, if any, in the same order. E.g. the contents of /proc/device-tree/compatible with each zero-terminated string as the array's element.",
        examples=[
            ['zyxel,nsa325', 'marvell,kirkwood-88f6282', 'marvell,kirkwood'],
            ['yna,cu1830-neo', 'ingenic,x1830'],
        ],
    )
    @field_validator('compatible')
    def validate_compatible(cls, v):
        if v:
            if isinstance(v, list):
                for item in v:
                    if not re.match(r'^[^ \0]+(,[^ \0]+)*$', item):
                        raise ValueError('Compatible cannot include null characters')
            else:
                raise ValueError('Compatible must be a list')
        return v
    comment: Optional[str] = Field(
        None, description='A human-readable comment regarding the environment.'
    )
    @field_validator('comment')
    def validate_comment(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Comment cannot include null characters')
        return v
    misc: Optional[Dict[str, Any]] = Field(
        None, description='Miscellaneous extra data about the environment'
    )


class Prefix(Enum):
    metric = 'metric'
    binary = 'binary'


class Number(BaseModel):
    class Config:
        extra = Extra.forbid

    value: float = Field(
        ...,
        description='The floating-point output value.\n\nThe receiving system should dedicate at least 64 bits for its storage.',
    )
    unit: Optional[str] = Field(
        None,
        description='The (compound) unit symbol(s) the value is measured in.\n\nIf includes unit prefixes, they should be used consistently to allow comparison of the values.\n\nAlternatively, the prefixes can be omitted from the unit, and the "prefix" can be specified. Based on that, and on the value itself, an appropriate prefix will be added to the unit string and the value will be scaled, when displaying.\n\nIf not specified, the value is considered dimensionless.',
        examples=['s', 'GB', 'MiB', 'B/s', 'IOPS'],
    )
    @field_validator('unit')
    def validate_unit(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Unit cannot include null characters')
        return v
    prefix: Optional[Prefix] = Field(
        None,
        description='The type of prefix to add to the unit, after the value is scaled. If unit is not specified, the prefix alone is used in its place.\n\nIf "binary", the value display scaling should be 1024-based, and the added prefix - binary. E.g. Ki, Mi, Gi, etc.\n\nIf "metric" the value display scaling should be 10-based, and the added prefix - metric. E.g. K, M, G, etc.\n\nNo scaling or prefix is applied, if not specified.',
    )


class Test(BaseModel):
    class Config:
        extra = Extra.forbid

    field_timestamp: Optional[datetime] = Field(
        None,
        alias='_timestamp',
        description='The last time the test was updated in the database.',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    build_id: str = Field(
        ...,
        description='ID of the tested build. The build must be valid for the test run to be considered valid.',
    )
    @field_validator('build_id')
    def validate_build_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('Build ID must be in the format "origin:id"')
        return v
    
    id: str = Field(
        ...,
        description="ID of the test run\n\nMust start with a non-empty string identifying the CI system which submitted the test run, followed by a colon ':' character. The rest of the string is generated by the origin CI system, and must identify the test run uniquely among all test runs, coming from that CI system.\n",
    )
    @field_validator('id')
    def validate_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('ID must be in the format "origin:id"')
        return v
    
    origin: str = Field(
        ..., description='The name of the CI system which submitted the test run'
    )
    @field_validator('origin')
    def validate_origin(cls, v):
        if not re.match(r'^[a-z0-9_]+$', v):
            raise ValueError('Origin must contain only alphanumeric characters and underscores')
        return v
    environment: Optional[Environment] = Field(
        None,
        description='The environment the test ran in. E.g. a host, a set of hosts, or a lab; amount of memory/storage/CPUs, for each host; process environment variables, etc.',
    )
    path: Optional[str] = Field(
        None,
        description='Dot-separated path to the node in the test classification tree the executed test belongs to. E.g. "ltp.sem01". The empty string signifies the root of the tree, i.e. all tests for the build, executed by the origin CI system.',
        examples=['', 'ltp', 'ltp.sem01'],
    )
    @field_validator('path')
    def validate_path(cls, v):
        if v and not re.match(r'^([a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)*)?$', v):
            raise ValueError('Path must contain only alphanumeric characters, underscores, and dots')
        return v
    
    comment: Optional[str] = Field(
        None, description='A human-readable comment regarding the test run'
    )
    @field_validator('comment')
    def validate_comment(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Comment cannot include null characters')
    
    log_url: Optional[AnyUrl] = Field(
        None,
        description='The URL of the plain-text test output or log file. If the test produced multiple outputs/files, this should point to the one containing the highest-level overview of the test\'s operation. The rest should go into "output_files".',
    )
    log_excerpt: Optional[str] = Field(
        None,
        description='A part of the test output/log file (which could be) referenced by "log_url", most relevant to the test outcome.',
        examples=[
            'netns_breakns_ns_exec_ipv4_ioctl FAIL 2\n',
            'kernel BUG at net/core/dev.c:2648!\n',
        ],
    )
    @field_validator('log_excerpt')
    def validate_log_excerpt(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Log excerpt cannot include null characters')
        return v
    
    status: Optional[Status] = Field(None, description='Test status')
    number: Optional[Number] = Field(
        None,
        description='The numerical output produced by the test.\n\nThe meaning of the output is determined by the particular test. Should only be considered when the test has actually executed. That is, with a "FAIL", "ERROR", "PASS", or "DONE" status only. Normally "DONE" should be used, when it\'s the main and not an auxiliary output.',
        examples=[
            {'value': 42},
            {'value': 3.14159},
            {'value': 720, 'unit': 'KB'},
            {'value': 145000, 'prefix': 'metric'},
            {'value': 1.6e-07, 'unit': 's', 'prefix': 'metric'},
            {'value': 512000.0, 'unit': 'B', 'prefix': 'binary'},
        ],
    )
    start_time: Optional[datetime] = Field(
        None,
        description='The time the test run was started',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    duration: Optional[float] = Field(
        None, description='The number of seconds it took to run the test'
    )
    output_files: Optional[List[Resource]] = Field(
        None,
        description='A list of test outputs: logs, dumps, etc. Except the file referenced by "log_url".',
    )
    misc: Optional[Dict[str, Any]] = Field(
        None, description='Miscellaneous extra data about the test run'
    )


class Culprit(BaseModel):
    class Config:
        extra = Extra.forbid

    code: Optional[bool] = Field(None, description='The built/tested code.')
    tool: Optional[bool] = Field(
        None,
        description='The tool - the static analyzer, the build toolchain, the test, etc.',
    )
    harness: Optional[bool] = Field(
        None,
        description='The harness - the system controlling the execution of the build/test.',
    )


class Issue(BaseModel):
    class Config:
        extra = Extra.forbid

    field_timestamp: Optional[datetime] = Field(
        None,
        alias='_timestamp',
        description='The last time the issue was updated in the database.',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    id: str = Field(
        ...,
        description="Issue ID\n\nMust start with a non-empty string identifying the CI system which submitted the checkout, followed by a colon ':' character. The rest of the string is generated by the origin CI system, and must identify the issue uniquely among all issues, coming from that CI system.\n",
    )
    @field_validator('id')
    def validate_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('ID must be in the format "origin:id"')
        return v
    
    version: int = Field(
        ...,
        description='The modification version number of the issue. Only the highest-numbered version is used for triaging.',
    )
    origin: str = Field(
        ..., description='The name of the CI system which submitted the issue'
    )
    @field_validator('origin')
    def validate_origin(cls, v):
        if not re.match(r'^[a-z0-9_]+$', v):
            raise ValueError('Origin must contain only alphanumeric characters and underscores')
        return v

    report_url: Optional[AnyUrl] = Field(
        None,
        description='The URL of a report describing the issue.',
        examples=['https://bugzilla.kernel.org/show_bug.cgi?id=207065'],
    )
    report_subject: Optional[str] = Field(
        None,
        description='The subject of the report describing the issue.',
        examples=['C-media USB audio device stops working from 5.2.0-rc3 onwards'],
    )
    @field_validator('report_subject')
    def validate_report_subject(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Report subject cannot include null characters')
        return v
    culprit: Optional[Culprit] = Field(
        None,
        description='Layers of the execution stack responsible for the issue. If all are false, the issue is considered invalid.',
    )
    comment: Optional[str] = Field(
        None,
        description='A human-readable comment regarding the issue. E.g. a brief description, or a report subject.',
    )
    @field_validator('comment')
    def validate_comment(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Comment cannot include null characters')
        return v
    misc: Optional[Dict[str, Any]] = Field(
        None, description='Miscellaneous extra data about the issue'
    )


class Incident(BaseModel):
    class Config:
        extra = Extra.forbid

    field_timestamp: Optional[datetime] = Field(
        None,
        alias='_timestamp',
        description='The last time the incident was updated in the database.',
        examples=['2020-08-14T23:08:06.967000+00:00'],
    )
    id: str = Field(
        ...,
        description="Incident ID\n\nMust start with a non-empty string identifying the CI system which submitted the incident, followed by a colon ':' character. The rest of the string is generated by the origin CI system, and must identify the incident uniquely among all incidents, coming from that CI system.\n",
    )
    @field_validator('id')
    def validate_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('ID must be in the format "origin:id"')
        return v
    origin: str = Field(
        ..., description='The name of the CI system which submitted the incident'
    )
    @field_validator('origin')
    def validate_origin(cls, v):
        if not re.match(r'^[a-z0-9_]+$', v):
            raise ValueError('Origin must contain only alphanumeric characters and underscores')
        return v
    
    issue_id: str = Field(
        ..., description='The ID of the occurring/absent issue.'
    )
    @field_validator('issue_id')
    def validate_issue_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('Issue ID must be in the format "origin:id"')
        return v
    issue_version: int = Field(
        ...,
        description='The modification version number of the occurring/absent issue.',
    )
    @field_validator('issue_version')
    def validate_issue_version(cls, v):
        if v < 0:
            raise ValueError('Issue version must be greater than 0')
        return v
    build_id: Optional[str] = Field(
        None, description='The ID of the build object exhibiting/missing the issue.'
    )
    @field_validator('build_id')
    def validate_build_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('Build ID must be in the format "origin:id"')
        return v
    test_id: Optional[str] = Field(
        None, description='The ID of the test object exhibiting/missing the issue.'
    )
    @field_validator('test_id')
    def validate_test_id(cls, v):
        if not re.match(r'^[a-z0-9_]+:[^\0]*$', v):
            raise ValueError('Test ID must be in the format "origin:id"')
        return v
    present: Optional[bool] = Field(
        None,
        description='True if the issue occurred in the linked objects. False if it was absent.',
    )
    comment: Optional[str] = Field(
        None, description='A human-readable comment regarding the incident.'
    )
    @field_validator('comment')
    def validate_comment(cls, v):
        if not re.match(r'^[^\0]*$', v):
            raise ValueError('Comment cannot include null characters')
        return v
    misc: Optional[Dict[str, Any]] = Field(
        None, description='Miscellaneous extra data about the incident.'
    )


class Kcidb(BaseModel):
    class Config:
        extra = Extra.forbid

    version: Version
    checkouts: Optional[List[Checkout]] = Field(
        None, description='List of source code checkouts'
    )
    builds: Optional[List[Build]] = Field(None, description='List of builds')
    tests: Optional[List[Test]] = Field(None, description='List of test runs')
    issues: Optional[List[Issue]] = Field(None, description='List of issues')
    incidents: Optional[List[Incident]] = Field(None, description='List of incidents')



